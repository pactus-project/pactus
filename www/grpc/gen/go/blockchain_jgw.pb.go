// Code generated by protoc-gen-jrpc-gateway. DO NOT EDIT.
// source: blockchain.proto

/*
Package pactus is a reverse proxy.

It translates gRPC into JSON-RPC 2.0
*/
package pactus

import (
	"context"
	"encoding/json"

	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/encoding/protojson"
)

type BlockchainServiceJsonRPC struct {
	client BlockchainServiceClient
}

type paramsAndHeadersBlockchainService struct {
	Headers metadata.MD     `json:"headers,omitempty"`
	Params  json.RawMessage `json:"params"`
}

// RegisterBlockchainServiceJsonRPC register the grpc client BlockchainService for json-rpc.
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterBlockchainServiceJsonRPC(conn *grpc.ClientConn) *BlockchainServiceJsonRPC {
	return &BlockchainServiceJsonRPC{
		client: NewBlockchainServiceClient(conn),
	}
}

func (s *BlockchainServiceJsonRPC) Methods() map[string]func(ctx context.Context, message json.RawMessage) (any, error) {
	return map[string]func(ctx context.Context, params json.RawMessage) (any, error){

		"pactus.blockchain_service.get_block": func(ctx context.Context, data json.RawMessage) (any, error) {
			req := new(GetBlockRequest)

			var jrpcData paramsAndHeadersBlockchainService

			if err := json.Unmarshal(data, &jrpcData); err != nil {
				return nil, err
			}

			err := protojson.Unmarshal(jrpcData.Params, req)
			if err != nil {
				return nil, err
			}

			return s.client.GetBlock(metadata.NewOutgoingContext(ctx, jrpcData.Headers), req)
		},

		"pactus.blockchain_service.get_block_hash": func(ctx context.Context, data json.RawMessage) (any, error) {
			req := new(GetBlockHashRequest)

			var jrpcData paramsAndHeadersBlockchainService

			if err := json.Unmarshal(data, &jrpcData); err != nil {
				return nil, err
			}

			err := protojson.Unmarshal(jrpcData.Params, req)
			if err != nil {
				return nil, err
			}

			return s.client.GetBlockHash(metadata.NewOutgoingContext(ctx, jrpcData.Headers), req)
		},

		"pactus.blockchain_service.get_block_height": func(ctx context.Context, data json.RawMessage) (any, error) {
			req := new(GetBlockHeightRequest)

			var jrpcData paramsAndHeadersBlockchainService

			if err := json.Unmarshal(data, &jrpcData); err != nil {
				return nil, err
			}

			err := protojson.Unmarshal(jrpcData.Params, req)
			if err != nil {
				return nil, err
			}

			return s.client.GetBlockHeight(metadata.NewOutgoingContext(ctx, jrpcData.Headers), req)
		},

		"pactus.blockchain_service.get_blockchain_info": func(ctx context.Context, data json.RawMessage) (any, error) {
			req := new(GetBlockchainInfoRequest)

			var jrpcData paramsAndHeadersBlockchainService

			if err := json.Unmarshal(data, &jrpcData); err != nil {
				return nil, err
			}

			err := protojson.Unmarshal(jrpcData.Params, req)
			if err != nil {
				return nil, err
			}

			return s.client.GetBlockchainInfo(metadata.NewOutgoingContext(ctx, jrpcData.Headers), req)
		},

		"pactus.blockchain_service.get_consensus_info": func(ctx context.Context, data json.RawMessage) (any, error) {
			req := new(GetConsensusInfoRequest)

			var jrpcData paramsAndHeadersBlockchainService

			if err := json.Unmarshal(data, &jrpcData); err != nil {
				return nil, err
			}

			err := protojson.Unmarshal(jrpcData.Params, req)
			if err != nil {
				return nil, err
			}

			return s.client.GetConsensusInfo(metadata.NewOutgoingContext(ctx, jrpcData.Headers), req)
		},

		"pactus.blockchain_service.get_account": func(ctx context.Context, data json.RawMessage) (any, error) {
			req := new(GetAccountRequest)

			var jrpcData paramsAndHeadersBlockchainService

			if err := json.Unmarshal(data, &jrpcData); err != nil {
				return nil, err
			}

			err := protojson.Unmarshal(jrpcData.Params, req)
			if err != nil {
				return nil, err
			}

			return s.client.GetAccount(metadata.NewOutgoingContext(ctx, jrpcData.Headers), req)
		},

		"pactus.blockchain_service.get_validator": func(ctx context.Context, data json.RawMessage) (any, error) {
			req := new(GetValidatorRequest)

			var jrpcData paramsAndHeadersBlockchainService

			if err := json.Unmarshal(data, &jrpcData); err != nil {
				return nil, err
			}

			err := protojson.Unmarshal(jrpcData.Params, req)
			if err != nil {
				return nil, err
			}

			return s.client.GetValidator(metadata.NewOutgoingContext(ctx, jrpcData.Headers), req)
		},

		"pactus.blockchain_service.get_validator_by_number": func(ctx context.Context, data json.RawMessage) (any, error) {
			req := new(GetValidatorByNumberRequest)

			var jrpcData paramsAndHeadersBlockchainService

			if err := json.Unmarshal(data, &jrpcData); err != nil {
				return nil, err
			}

			err := protojson.Unmarshal(jrpcData.Params, req)
			if err != nil {
				return nil, err
			}

			return s.client.GetValidatorByNumber(metadata.NewOutgoingContext(ctx, jrpcData.Headers), req)
		},

		"pactus.blockchain_service.get_validator_addresses": func(ctx context.Context, data json.RawMessage) (any, error) {
			req := new(GetValidatorAddressesRequest)

			var jrpcData paramsAndHeadersBlockchainService

			if err := json.Unmarshal(data, &jrpcData); err != nil {
				return nil, err
			}

			err := protojson.Unmarshal(jrpcData.Params, req)
			if err != nil {
				return nil, err
			}

			return s.client.GetValidatorAddresses(metadata.NewOutgoingContext(ctx, jrpcData.Headers), req)
		},

		"pactus.blockchain_service.get_public_key": func(ctx context.Context, data json.RawMessage) (any, error) {
			req := new(GetPublicKeyRequest)

			var jrpcData paramsAndHeadersBlockchainService

			if err := json.Unmarshal(data, &jrpcData); err != nil {
				return nil, err
			}

			err := protojson.Unmarshal(jrpcData.Params, req)
			if err != nil {
				return nil, err
			}

			return s.client.GetPublicKey(metadata.NewOutgoingContext(ctx, jrpcData.Headers), req)
		},

		"pactus.blockchain_service.get_tx_pool_content": func(ctx context.Context, data json.RawMessage) (any, error) {
			req := new(GetTxPoolContentRequest)

			var jrpcData paramsAndHeadersBlockchainService

			if err := json.Unmarshal(data, &jrpcData); err != nil {
				return nil, err
			}

			err := protojson.Unmarshal(jrpcData.Params, req)
			if err != nil {
				return nil, err
			}

			return s.client.GetTxPoolContent(metadata.NewOutgoingContext(ctx, jrpcData.Headers), req)
		},
	}
}
