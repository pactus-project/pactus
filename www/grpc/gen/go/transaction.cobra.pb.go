// Code generated by protoc-gen-cobra. DO NOT EDIT.

package pactus

import (
	client "github.com/NathanBaulch/protoc-gen-cobra/client"
	flag "github.com/NathanBaulch/protoc-gen-cobra/flag"
	iocodec "github.com/NathanBaulch/protoc-gen-cobra/iocodec"
	cobra "github.com/spf13/cobra"
	grpc "google.golang.org/grpc"
	proto "google.golang.org/protobuf/proto"
)

func TransactionClientCommand(options ...client.Option) *cobra.Command {
	cfg := client.NewConfig(options...)
	cmd := &cobra.Command{
		Use:   cfg.CommandNamer("Transaction"),
		Short: "Transaction service client",
		Long:  "Transaction service defines various RPC methods for interacting with\n transactions.",
	}
	cfg.BindFlags(cmd.PersistentFlags())
	cmd.AddCommand(
		_TransactionGetTransactionCommand(cfg),
		_TransactionCalculateFeeCommand(cfg),
		_TransactionBroadcastTransactionCommand(cfg),
		_TransactionGetRawTransactionCommand(cfg),
	)
	return cmd
}

func _TransactionGetTransactionCommand(cfg *client.Config) *cobra.Command {
	req := &GetTransactionRequest{}

	cmd := &cobra.Command{
		Use:   cfg.CommandNamer("GetTransaction"),
		Short: "GetTransaction RPC client",
		Long:  "GetTransaction retrieves transaction details based on the provided request\n parameters.",
		RunE: func(cmd *cobra.Command, args []string) error {
			if cfg.UseEnvVars {
				if err := flag.SetFlagsFromEnv(cmd.Parent().PersistentFlags(), true, cfg.EnvVarNamer, cfg.EnvVarPrefix, "Transaction"); err != nil {
					return err
				}
				if err := flag.SetFlagsFromEnv(cmd.PersistentFlags(), false, cfg.EnvVarNamer, cfg.EnvVarPrefix, "Transaction", "GetTransaction"); err != nil {
					return err
				}
			}
			return client.RoundTrip(cmd.Context(), cfg, func(cc grpc.ClientConnInterface, in iocodec.Decoder, out iocodec.Encoder) error {
				cli := NewTransactionClient(cc)
				v := &GetTransactionRequest{}

				if err := in(v); err != nil {
					return err
				}
				proto.Merge(v, req)

				res, err := cli.GetTransaction(cmd.Context(), v)

				if err != nil {
					return err
				}

				return out(res)

			})
		},
	}

	cmd.PersistentFlags().StringVar(&req.Id, cfg.FlagNamer("Id"), "", "The unique ID of the transaction to retrieve.")
	flag.EnumVar(cmd.PersistentFlags(), &req.Verbosity, cfg.FlagNamer("Verbosity"), "The verbosity level for transaction details.")

	return cmd
}

func _TransactionCalculateFeeCommand(cfg *client.Config) *cobra.Command {
	req := &CalculateFeeRequest{}

	cmd := &cobra.Command{
		Use:   cfg.CommandNamer("CalculateFee"),
		Short: "CalculateFee RPC client",
		Long:  "CalculateFee calculates the transaction fee based on the specified amount\n and payload type.",
		RunE: func(cmd *cobra.Command, args []string) error {
			if cfg.UseEnvVars {
				if err := flag.SetFlagsFromEnv(cmd.Parent().PersistentFlags(), true, cfg.EnvVarNamer, cfg.EnvVarPrefix, "Transaction"); err != nil {
					return err
				}
				if err := flag.SetFlagsFromEnv(cmd.PersistentFlags(), false, cfg.EnvVarNamer, cfg.EnvVarPrefix, "Transaction", "CalculateFee"); err != nil {
					return err
				}
			}
			return client.RoundTrip(cmd.Context(), cfg, func(cc grpc.ClientConnInterface, in iocodec.Decoder, out iocodec.Encoder) error {
				cli := NewTransactionClient(cc)
				v := &CalculateFeeRequest{}

				if err := in(v); err != nil {
					return err
				}
				proto.Merge(v, req)

				res, err := cli.CalculateFee(cmd.Context(), v)

				if err != nil {
					return err
				}

				return out(res)

			})
		},
	}

	cmd.PersistentFlags().Int64Var(&req.Amount, cfg.FlagNamer("Amount"), 0, "The amount involved in the transaction, specified in NanoPAC.")
	flag.EnumVar(cmd.PersistentFlags(), &req.PayloadType, cfg.FlagNamer("PayloadType"), "The type of transaction payload.")
	cmd.PersistentFlags().BoolVar(&req.FixedAmount, cfg.FlagNamer("FixedAmount"), false, "Indicates if the amount should be fixed and include the fee.")

	return cmd
}

func _TransactionBroadcastTransactionCommand(cfg *client.Config) *cobra.Command {
	req := &BroadcastTransactionRequest{}

	cmd := &cobra.Command{
		Use:   cfg.CommandNamer("BroadcastTransaction"),
		Short: "BroadcastTransaction RPC client",
		Long:  "BroadcastTransaction broadcasts a signed transaction to the network.",
		RunE: func(cmd *cobra.Command, args []string) error {
			if cfg.UseEnvVars {
				if err := flag.SetFlagsFromEnv(cmd.Parent().PersistentFlags(), true, cfg.EnvVarNamer, cfg.EnvVarPrefix, "Transaction"); err != nil {
					return err
				}
				if err := flag.SetFlagsFromEnv(cmd.PersistentFlags(), false, cfg.EnvVarNamer, cfg.EnvVarPrefix, "Transaction", "BroadcastTransaction"); err != nil {
					return err
				}
			}
			return client.RoundTrip(cmd.Context(), cfg, func(cc grpc.ClientConnInterface, in iocodec.Decoder, out iocodec.Encoder) error {
				cli := NewTransactionClient(cc)
				v := &BroadcastTransactionRequest{}

				if err := in(v); err != nil {
					return err
				}
				proto.Merge(v, req)

				res, err := cli.BroadcastTransaction(cmd.Context(), v)

				if err != nil {
					return err
				}

				return out(res)

			})
		},
	}

	cmd.PersistentFlags().StringVar(&req.SignedRawTransaction, cfg.FlagNamer("SignedRawTransaction"), "", "The signed raw transaction data to be broadcasted.")

	return cmd
}

func _TransactionGetRawTransactionCommand(cfg *client.Config) *cobra.Command {
	req := &GetRawTransactionRequest{}

	cmd := &cobra.Command{
		Use:   cfg.CommandNamer("GetRawTransaction"),
		Short: "GetRawTransaction RPC client",
		Long:  "GetRawTransaction retrieves raw details of transfer, bond, unbond or withdraw transaction.",
		RunE: func(cmd *cobra.Command, args []string) error {
			if cfg.UseEnvVars {
				if err := flag.SetFlagsFromEnv(cmd.Parent().PersistentFlags(), true, cfg.EnvVarNamer, cfg.EnvVarPrefix, "Transaction"); err != nil {
					return err
				}
				if err := flag.SetFlagsFromEnv(cmd.PersistentFlags(), false, cfg.EnvVarNamer, cfg.EnvVarPrefix, "Transaction", "GetRawTransaction"); err != nil {
					return err
				}
			}
			return client.RoundTrip(cmd.Context(), cfg, func(cc grpc.ClientConnInterface, in iocodec.Decoder, out iocodec.Encoder) error {
				cli := NewTransactionClient(cc)
				v := &GetRawTransactionRequest{}

				if err := in(v); err != nil {
					return err
				}
				proto.Merge(v, req)

				res, err := cli.GetRawTransaction(cmd.Context(), v)

				if err != nil {
					return err
				}

				return out(res)

			})
		},
	}

	cmd.PersistentFlags().Uint32Var(&req.LockTime, cfg.FlagNamer("LockTime"), 0, "The lock time for the transaction. If not set, defaults to the last block\n height.")
	cmd.PersistentFlags().StringVar(&req.Memo, cfg.FlagNamer("Memo"), "", "A memo string for the transaction.")
	_Transfer := &GetRawTransferTransactionRequest{}
	cmd.PersistentFlags().Bool(cfg.FlagNamer("Transfer"), false, "")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Transfer"), func() { req.Transaction = &GetRawTransactionRequest_Transfer{Transfer: _Transfer} })
	cmd.PersistentFlags().StringVar(&_Transfer.Sender, cfg.FlagNamer("Transfer Sender"), "", "The sender's account address.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Transfer Sender"), func() { req.Transaction = &GetRawTransactionRequest_Transfer{Transfer: _Transfer} })
	cmd.PersistentFlags().StringVar(&_Transfer.Receiver, cfg.FlagNamer("Transfer Receiver"), "", "The receiver's account address.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Transfer Receiver"), func() { req.Transaction = &GetRawTransactionRequest_Transfer{Transfer: _Transfer} })
	cmd.PersistentFlags().Int64Var(&_Transfer.Amount, cfg.FlagNamer("Transfer Amount"), 0, "The amount to be transferred, specified in NanoPAC. Must be greater than 0.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Transfer Amount"), func() { req.Transaction = &GetRawTransactionRequest_Transfer{Transfer: _Transfer} })
	cmd.PersistentFlags().Int64Var(&_Transfer.Fee, cfg.FlagNamer("Transfer Fee"), 0, "The transaction fee in NanoPAC. If not set, it is set to the estimated fee.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Transfer Fee"), func() { req.Transaction = &GetRawTransactionRequest_Transfer{Transfer: _Transfer} })
	_Bond := &GetRawBondTransactionRequest{}
	cmd.PersistentFlags().Bool(cfg.FlagNamer("Bond"), false, "")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Bond"), func() { req.Transaction = &GetRawTransactionRequest_Bond{Bond: _Bond} })
	cmd.PersistentFlags().StringVar(&_Bond.Sender, cfg.FlagNamer("Bond Sender"), "", "The sender's account address.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Bond Sender"), func() { req.Transaction = &GetRawTransactionRequest_Bond{Bond: _Bond} })
	cmd.PersistentFlags().StringVar(&_Bond.Receiver, cfg.FlagNamer("Bond Receiver"), "", "The receiver's validator address.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Bond Receiver"), func() { req.Transaction = &GetRawTransactionRequest_Bond{Bond: _Bond} })
	cmd.PersistentFlags().Int64Var(&_Bond.Stake, cfg.FlagNamer("Bond Stake"), 0, "The stake amount in NanoPAC. Must be greater than 0.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Bond Stake"), func() { req.Transaction = &GetRawTransactionRequest_Bond{Bond: _Bond} })
	cmd.PersistentFlags().StringVar(&_Bond.PublicKey, cfg.FlagNamer("Bond PublicKey"), "", "The public key of the validator.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Bond PublicKey"), func() { req.Transaction = &GetRawTransactionRequest_Bond{Bond: _Bond} })
	cmd.PersistentFlags().Int64Var(&_Bond.Fee, cfg.FlagNamer("Bond Fee"), 0, "The transaction fee in NanoPAC. If not set, it is set to the estimated fee.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Bond Fee"), func() { req.Transaction = &GetRawTransactionRequest_Bond{Bond: _Bond} })
	_Unbond := &GetRawUnbondTransactionRequest{}
	cmd.PersistentFlags().Bool(cfg.FlagNamer("Unbond"), false, "")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Unbond"), func() { req.Transaction = &GetRawTransactionRequest_Unbond{Unbond: _Unbond} })
	cmd.PersistentFlags().StringVar(&_Unbond.ValidatorAddress, cfg.FlagNamer("Unbond ValidatorAddress"), "", "The address of the validator to unbond from.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Unbond ValidatorAddress"), func() { req.Transaction = &GetRawTransactionRequest_Unbond{Unbond: _Unbond} })
	_Withdraw := &GetRawWithdrawTransactionRequest{}
	cmd.PersistentFlags().Bool(cfg.FlagNamer("Withdraw"), false, "")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Withdraw"), func() { req.Transaction = &GetRawTransactionRequest_Withdraw{Withdraw: _Withdraw} })
	cmd.PersistentFlags().StringVar(&_Withdraw.ValidatorAddress, cfg.FlagNamer("Withdraw ValidatorAddress"), "", "The address of the validator to withdraw from.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Withdraw ValidatorAddress"), func() { req.Transaction = &GetRawTransactionRequest_Withdraw{Withdraw: _Withdraw} })
	cmd.PersistentFlags().StringVar(&_Withdraw.AccountAddress, cfg.FlagNamer("Withdraw AccountAddress"), "", "The address of the account to withdraw to.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Withdraw AccountAddress"), func() { req.Transaction = &GetRawTransactionRequest_Withdraw{Withdraw: _Withdraw} })
	cmd.PersistentFlags().Int64Var(&_Withdraw.Amount, cfg.FlagNamer("Withdraw Amount"), 0, "The withdrawal amount in NanoPAC. Must be greater than 0.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Withdraw Amount"), func() { req.Transaction = &GetRawTransactionRequest_Withdraw{Withdraw: _Withdraw} })
	cmd.PersistentFlags().Int64Var(&_Withdraw.Fee, cfg.FlagNamer("Withdraw Fee"), 0, "The transaction fee in NanoPAC. If not set, it is set to the estimated fee.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Withdraw Fee"), func() { req.Transaction = &GetRawTransactionRequest_Withdraw{Withdraw: _Withdraw} })

	return cmd
}
