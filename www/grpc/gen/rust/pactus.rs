// @generated
// This file is @generated by prost-build.
/// Request message for retrieving transaction details.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTransactionRequest {
    /// The unique ID of the transaction to retrieve.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// The verbosity level for transaction details.
    #[prost(enumeration="TransactionVerbosity", tag="2")]
    pub verbosity: i32,
}
/// Response message contains details of a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionResponse {
    /// The height of the block containing the transaction.
    #[prost(uint32, tag="1")]
    pub block_height: u32,
    /// The UNIX timestamp of the block containing the transaction.
    #[prost(uint32, tag="2")]
    pub block_time: u32,
    /// Detailed information about the transaction.
    #[prost(message, optional, tag="3")]
    pub transaction: ::core::option::Option<TransactionInfo>,
}
/// Request message for calculating transaction fee.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CalculateFeeRequest {
    /// The amount involved in the transaction, specified in NanoPAC.
    #[prost(int64, tag="1")]
    pub amount: i64,
    /// The type of transaction payload.
    #[prost(enumeration="PayloadType", tag="2")]
    pub payload_type: i32,
    /// Indicates if the amount should be fixed and include the fee.
    #[prost(bool, tag="3")]
    pub fixed_amount: bool,
}
/// Response message contains the calculated transaction fee.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CalculateFeeResponse {
    /// The calculated amount in NanoPAC.
    #[prost(int64, tag="1")]
    pub amount: i64,
    /// The calculated transaction fee in NanoPAC.
    #[prost(int64, tag="2")]
    pub fee: i64,
}
/// Request message for broadcasting a signed transaction to the network.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BroadcastTransactionRequest {
    /// The signed raw transaction data to be broadcasted.
    #[prost(string, tag="1")]
    pub signed_raw_transaction: ::prost::alloc::string::String,
}
/// Response message contains the ID of the broadcasted transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BroadcastTransactionResponse {
    /// The unique ID of the broadcasted transaction.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
/// Request message for retrieving raw details of a transfer transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRawTransferTransactionRequest {
    /// The lock time for the transaction. If not set, defaults to the last block height.
    #[prost(uint32, tag="1")]
    pub lock_time: u32,
    /// The sender's account address.
    #[prost(string, tag="2")]
    pub sender: ::prost::alloc::string::String,
    /// The receiver's account address.
    #[prost(string, tag="3")]
    pub receiver: ::prost::alloc::string::String,
    /// The amount to be transferred, specified in NanoPAC. Must be greater than 0.
    #[prost(int64, tag="4")]
    pub amount: i64,
    /// The transaction fee in NanoPAC. If not set, it is set to the estimated fee.
    #[prost(int64, tag="5")]
    pub fee: i64,
    /// A memo string for the transaction.
    #[prost(string, tag="6")]
    pub memo: ::prost::alloc::string::String,
}
/// Request message for retrieving raw details of a bond transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRawBondTransactionRequest {
    /// The lock time for the transaction. If not set, defaults to the last block height.
    #[prost(uint32, tag="1")]
    pub lock_time: u32,
    /// The sender's account address.
    #[prost(string, tag="2")]
    pub sender: ::prost::alloc::string::String,
    /// The receiver's validator address.
    #[prost(string, tag="3")]
    pub receiver: ::prost::alloc::string::String,
    /// The stake amount in NanoPAC. Must be greater than 0.
    #[prost(int64, tag="4")]
    pub stake: i64,
    /// The public key of the validator. Optional, but required when registering a new validator.
    #[prost(string, tag="5")]
    pub public_key: ::prost::alloc::string::String,
    /// The transaction fee in NanoPAC. If not set, it is set to the estimated fee.
    #[prost(int64, tag="6")]
    pub fee: i64,
    /// A memo string for the transaction.
    #[prost(string, tag="7")]
    pub memo: ::prost::alloc::string::String,
}
/// Request message for retrieving raw details of an unbond transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRawUnbondTransactionRequest {
    /// The lock time for the transaction. If not set, defaults to the last block height.
    #[prost(uint32, tag="1")]
    pub lock_time: u32,
    /// The address of the validator to unbond from.
    #[prost(string, tag="3")]
    pub validator_address: ::prost::alloc::string::String,
    /// A memo string for the transaction.
    #[prost(string, tag="4")]
    pub memo: ::prost::alloc::string::String,
}
/// Request message for retrieving raw details of a withdraw transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRawWithdrawTransactionRequest {
    /// The lock time for the transaction. If not set, defaults to the last block height.
    #[prost(uint32, tag="1")]
    pub lock_time: u32,
    /// The address of the validator to withdraw from.
    #[prost(string, tag="2")]
    pub validator_address: ::prost::alloc::string::String,
    /// The address of the account to withdraw to.
    #[prost(string, tag="3")]
    pub account_address: ::prost::alloc::string::String,
    /// The withdrawal amount in NanoPAC. Must be greater than 0.
    #[prost(int64, tag="4")]
    pub amount: i64,
    /// The transaction fee in NanoPAC. If not set, it is set to the estimated fee.
    #[prost(int64, tag="5")]
    pub fee: i64,
    /// A memo string for the transaction.
    #[prost(string, tag="6")]
    pub memo: ::prost::alloc::string::String,
}
/// Request message for retrieving raw details of a batch transfer transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRawBatchTransferTransactionRequest {
    /// The lock time for the transaction. If not set, defaults to the last block height.
    #[prost(uint32, tag="1")]
    pub lock_time: u32,
    /// The sender's account address.
    #[prost(string, tag="2")]
    pub sender: ::prost::alloc::string::String,
    /// The list of recipients with their amounts. Minimum 2 recipients required.
    #[prost(message, repeated, tag="3")]
    pub recipients: ::prost::alloc::vec::Vec<Recipient>,
    /// The transaction fee in NanoPAC. If not set, it is set to the estimated fee.
    #[prost(int64, tag="4")]
    pub fee: i64,
    /// A memo string for the transaction.
    #[prost(string, tag="5")]
    pub memo: ::prost::alloc::string::String,
}
/// Response message contains raw transaction data.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRawTransactionResponse {
    /// The raw transaction data in hexadecimal format.
    #[prost(string, tag="1")]
    pub raw_transaction: ::prost::alloc::string::String,
    /// The unique ID of the transaction.
    #[prost(string, tag="2")]
    pub id: ::prost::alloc::string::String,
}
/// Payload for a transfer transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PayloadTransfer {
    /// The sender's address.
    #[prost(string, tag="1")]
    pub sender: ::prost::alloc::string::String,
    /// The receiver's address.
    #[prost(string, tag="2")]
    pub receiver: ::prost::alloc::string::String,
    /// The amount to be transferred in NanoPAC.
    #[prost(int64, tag="3")]
    pub amount: i64,
}
/// Payload for a bond transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PayloadBond {
    /// The sender's address.
    #[prost(string, tag="1")]
    pub sender: ::prost::alloc::string::String,
    /// The receiver's address.
    #[prost(string, tag="2")]
    pub receiver: ::prost::alloc::string::String,
    /// The stake amount in NanoPAC.
    #[prost(int64, tag="3")]
    pub stake: i64,
    /// The public key of the validator.
    #[prost(string, tag="4")]
    pub public_key: ::prost::alloc::string::String,
}
/// Payload for a sortition transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PayloadSortition {
    /// The validator address associated with the sortition proof.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    /// The proof for the sortition.
    #[prost(string, tag="2")]
    pub proof: ::prost::alloc::string::String,
}
/// Payload for an unbond transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PayloadUnbond {
    /// The address of the validator to unbond from.
    #[prost(string, tag="1")]
    pub validator: ::prost::alloc::string::String,
}
/// Payload for a withdraw transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PayloadWithdraw {
    /// The address of the validator to withdraw from.
    #[prost(string, tag="1")]
    pub validator_address: ::prost::alloc::string::String,
    /// The address of the account to withdraw to.
    #[prost(string, tag="2")]
    pub account_address: ::prost::alloc::string::String,
    /// The withdrawal amount in NanoPAC.
    #[prost(int64, tag="3")]
    pub amount: i64,
}
/// Payload for a batch transfer transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayloadBatchTransfer {
    /// The sender's address.
    #[prost(string, tag="1")]
    pub sender: ::prost::alloc::string::String,
    /// The list of recipients with their amounts.
    #[prost(message, repeated, tag="2")]
    pub recipients: ::prost::alloc::vec::Vec<Recipient>,
}
/// Recipient is receiver with amount.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Recipient {
    /// The receiver's address.
    #[prost(string, tag="1")]
    pub receiver: ::prost::alloc::string::String,
    /// The amount in NanoPAC.
    #[prost(int64, tag="2")]
    pub amount: i64,
}
/// Information about a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionInfo {
    /// The unique ID of the transaction.
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// The raw transaction data in hexadecimal format.
    #[prost(string, tag="2")]
    pub data: ::prost::alloc::string::String,
    /// The version of the transaction.
    #[prost(int32, tag="3")]
    pub version: i32,
    /// The lock time for the transaction.
    #[prost(uint32, tag="4")]
    pub lock_time: u32,
    /// The value of the transaction in NanoPAC.
    #[prost(int64, tag="5")]
    pub value: i64,
    /// The fee for the transaction in NanoPAC.
    #[prost(int64, tag="6")]
    pub fee: i64,
    /// The type of transaction payload.
    #[prost(enumeration="PayloadType", tag="7")]
    pub payload_type: i32,
    /// A memo string for the transaction.
    #[prost(string, tag="8")]
    pub memo: ::prost::alloc::string::String,
    /// The public key associated with the transaction.
    #[prost(string, tag="9")]
    pub public_key: ::prost::alloc::string::String,
    /// The signature for the transaction.
    #[prost(string, tag="10")]
    pub signature: ::prost::alloc::string::String,
    /// The block height containing the transaction.
    /// A value of zero means the transaction is unconfirmed and may still in the transaction pool.
    #[prost(uint32, tag="11")]
    pub block_height: u32,
    /// Indicates whether the transaction is confirmed.
    #[prost(bool, tag="12")]
    pub confirmed: bool,
    /// The number of blocks that have been added to the chain after this transaction was included in a block.
    /// A value of zero means the transaction is unconfirmed and may still in the transaction pool.
    #[prost(int32, tag="13")]
    pub confirmations: i32,
    /// Transaction payload.
    #[prost(oneof="transaction_info::Payload", tags="30, 31, 32, 33, 34, 35")]
    pub payload: ::core::option::Option<transaction_info::Payload>,
}
/// Nested message and enum types in `TransactionInfo`.
pub mod transaction_info {
    /// Transaction payload.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// Transfer transaction payload.
        #[prost(message, tag="30")]
        Transfer(super::PayloadTransfer),
        /// Bond transaction payload.
        #[prost(message, tag="31")]
        Bond(super::PayloadBond),
        /// Sortition transaction payload.
        #[prost(message, tag="32")]
        Sortition(super::PayloadSortition),
        /// Unbond transaction payload.
        #[prost(message, tag="33")]
        Unbond(super::PayloadUnbond),
        /// Withdraw transaction payload.
        #[prost(message, tag="34")]
        Withdraw(super::PayloadWithdraw),
        /// Batch Transfer transaction payload.
        #[prost(message, tag="35")]
        BatchTransfer(super::PayloadBatchTransfer),
    }
}
/// Request message for decoding a raw transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DecodeRawTransactionRequest {
    /// The raw transaction data in hexadecimal format.
    #[prost(string, tag="1")]
    pub raw_transaction: ::prost::alloc::string::String,
}
/// Response message contains the decoded transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecodeRawTransactionResponse {
    /// The decoded transaction information.
    #[prost(message, optional, tag="1")]
    pub transaction: ::core::option::Option<TransactionInfo>,
}
/// Enumeration for different types of transaction payloads.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PayloadType {
    /// Unspecified payload type.
    Unspecified = 0,
    /// Transfer payload type.
    Transfer = 1,
    /// Bond payload type.
    Bond = 2,
    /// Sortition payload type.
    Sortition = 3,
    /// Unbond payload type.
    Unbond = 4,
    /// Withdraw payload type.
    Withdraw = 5,
    /// Batch transfer payload type.
    BatchTransfer = 6,
}
impl PayloadType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PAYLOAD_TYPE_UNSPECIFIED",
            Self::Transfer => "PAYLOAD_TYPE_TRANSFER",
            Self::Bond => "PAYLOAD_TYPE_BOND",
            Self::Sortition => "PAYLOAD_TYPE_SORTITION",
            Self::Unbond => "PAYLOAD_TYPE_UNBOND",
            Self::Withdraw => "PAYLOAD_TYPE_WITHDRAW",
            Self::BatchTransfer => "PAYLOAD_TYPE_BATCH_TRANSFER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAYLOAD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PAYLOAD_TYPE_TRANSFER" => Some(Self::Transfer),
            "PAYLOAD_TYPE_BOND" => Some(Self::Bond),
            "PAYLOAD_TYPE_SORTITION" => Some(Self::Sortition),
            "PAYLOAD_TYPE_UNBOND" => Some(Self::Unbond),
            "PAYLOAD_TYPE_WITHDRAW" => Some(Self::Withdraw),
            "PAYLOAD_TYPE_BATCH_TRANSFER" => Some(Self::BatchTransfer),
            _ => None,
        }
    }
}
/// Enumeration for verbosity levels when requesting transaction details.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionVerbosity {
    /// Request transaction data only.
    Data = 0,
    /// Request detailed transaction information.
    Info = 1,
}
impl TransactionVerbosity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Data => "TRANSACTION_VERBOSITY_DATA",
            Self::Info => "TRANSACTION_VERBOSITY_INFO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_VERBOSITY_DATA" => Some(Self::Data),
            "TRANSACTION_VERBOSITY_INFO" => Some(Self::Info),
            _ => None,
        }
    }
}
/// Request message for retrieving account information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAccountRequest {
    /// The address of the account to retrieve information for.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
}
/// Response message contains account information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAccountResponse {
    /// Detailed information about the account.
    #[prost(message, optional, tag="1")]
    pub account: ::core::option::Option<AccountInfo>,
}
/// Request message for retrieving validator addresses.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetValidatorAddressesRequest {
}
/// Response message contains list of validator addresses.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetValidatorAddressesResponse {
    /// List of validator addresses.
    #[prost(string, repeated, tag="1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for retrieving validator information by address.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetValidatorRequest {
    /// The address of the validator to retrieve information for.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
}
/// Request message for retrieving validator information by number.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetValidatorByNumberRequest {
    /// The unique number of the validator to retrieve information for.
    #[prost(int32, tag="1")]
    pub number: i32,
}
/// Response message contains validator information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetValidatorResponse {
    /// Detailed information about the validator.
    #[prost(message, optional, tag="1")]
    pub validator: ::core::option::Option<ValidatorInfo>,
}
/// Request message for retrieving public key by address.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPublicKeyRequest {
    /// The address for which to retrieve the public key.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
}
/// Response message contains public key information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPublicKeyResponse {
    /// The public key associated with the provided address.
    #[prost(string, tag="1")]
    pub public_key: ::prost::alloc::string::String,
}
/// Request message for retrieving block information based on height and verbosity level.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBlockRequest {
    /// The height of the block to retrieve.
    #[prost(uint32, tag="1")]
    pub height: u32,
    /// The verbosity level for block information.
    #[prost(enumeration="BlockVerbosity", tag="2")]
    pub verbosity: i32,
}
/// Response message contains block information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockResponse {
    /// The height of the block.
    #[prost(uint32, tag="1")]
    pub height: u32,
    /// The hash of the block.
    #[prost(string, tag="2")]
    pub hash: ::prost::alloc::string::String,
    /// Block data, available only if verbosity level is set to BLOCK_VERBOSITY_DATA.
    #[prost(string, tag="3")]
    pub data: ::prost::alloc::string::String,
    /// The timestamp of the block.
    #[prost(uint32, tag="4")]
    pub block_time: u32,
    /// Header information of the block.
    #[prost(message, optional, tag="5")]
    pub header: ::core::option::Option<BlockHeaderInfo>,
    /// Certificate information of the previous block.
    #[prost(message, optional, tag="6")]
    pub prev_cert: ::core::option::Option<CertificateInfo>,
    /// List of transactions in the block, available when verbosity level is set to
    /// BLOCK_VERBOSITY_TRANSACTIONS.
    #[prost(message, repeated, tag="7")]
    pub txs: ::prost::alloc::vec::Vec<TransactionInfo>,
}
/// Request message for retrieving block hash by height.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBlockHashRequest {
    /// The height of the block to retrieve the hash for.
    #[prost(uint32, tag="1")]
    pub height: u32,
}
/// Response message contains block hash.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBlockHashResponse {
    /// The hash of the block.
    #[prost(string, tag="1")]
    pub hash: ::prost::alloc::string::String,
}
/// Request message for retrieving block height by hash.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBlockHeightRequest {
    /// The hash of the block to retrieve the height for.
    #[prost(string, tag="1")]
    pub hash: ::prost::alloc::string::String,
}
/// Response message contains block height.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBlockHeightResponse {
    /// The height of the block.
    #[prost(uint32, tag="1")]
    pub height: u32,
}
/// Request message for retrieving blockchain information.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBlockchainInfoRequest {
}
/// Response message contains general blockchain information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBlockchainInfoResponse {
    /// The height of the last block in the blockchain.
    #[prost(uint32, tag="1")]
    pub last_block_height: u32,
    /// The hash of the last block in the blockchain.
    #[prost(string, tag="2")]
    pub last_block_hash: ::prost::alloc::string::String,
    /// The timestamp of the last block in Unix format.
    #[prost(int64, tag="10")]
    pub last_block_time: i64,
    /// The total number of accounts in the blockchain.
    #[prost(int32, tag="3")]
    pub total_accounts: i32,
    /// The total number of validators in the blockchain.
    #[prost(int32, tag="4")]
    pub total_validators: i32,
    /// The number of active (not unbonded) validators in the blockchain.
    #[prost(int32, tag="12")]
    pub active_validators: i32,
    /// The total power of the blockchain.
    #[prost(int64, tag="5")]
    pub total_power: i64,
    /// The power of the committee.
    #[prost(int64, tag="6")]
    pub committee_power: i64,
    /// If the blocks are subject to pruning.
    #[prost(bool, tag="8")]
    pub is_pruned: bool,
    /// Lowest-height block stored (only present if pruning is enabled)
    #[prost(uint32, tag="9")]
    pub pruning_height: u32,
    /// Indicates whether this node participates in consensus: true if at least one
    /// of its running validators is a member of the current committee.
    #[prost(bool, tag="13")]
    pub in_committee: bool,
}
/// Request message for retrieving committee information.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCommitteeInfoRequest {
}
/// Response message contains committee information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommitteeInfoResponse {
    /// The power of the committee.
    #[prost(int64, tag="1")]
    pub committee_power: i64,
    /// List of committee validators.
    #[prost(message, repeated, tag="2")]
    pub validators: ::prost::alloc::vec::Vec<ValidatorInfo>,
    /// Map of protocol versions and their percentages in the committee.
    #[prost(map="int32, double", tag="3")]
    pub protocol_versions: ::std::collections::HashMap<i32, f64>,
}
/// Request message for retrieving consensus information.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConsensusInfoRequest {
}
/// Response message contains consensus information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConsensusInfoResponse {
    /// The proposal of the consensus info.
    #[prost(message, optional, tag="1")]
    pub proposal: ::core::option::Option<ProposalInfo>,
    /// List of consensus instances.
    #[prost(message, repeated, tag="2")]
    pub instances: ::prost::alloc::vec::Vec<ConsensusInfo>,
}
/// Request message for retrieving transactions in the transaction pool.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTxPoolContentRequest {
    /// The type of transactions to retrieve from the transaction pool. 0 means all types.
    #[prost(enumeration="PayloadType", tag="1")]
    pub payload_type: i32,
}
/// Response message contains transactions in the transaction pool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTxPoolContentResponse {
    /// List of transactions currently in the pool.
    #[prost(message, repeated, tag="1")]
    pub txs: ::prost::alloc::vec::Vec<TransactionInfo>,
}
/// Message contains information about a validator.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorInfo {
    /// The hash of the validator.
    #[prost(string, tag="1")]
    pub hash: ::prost::alloc::string::String,
    /// The serialized data of the validator.
    #[prost(string, tag="2")]
    pub data: ::prost::alloc::string::String,
    /// The public key of the validator.
    #[prost(string, tag="3")]
    pub public_key: ::prost::alloc::string::String,
    /// The unique number assigned to the validator.
    #[prost(int32, tag="4")]
    pub number: i32,
    /// The stake of the validator in NanoPAC.
    #[prost(int64, tag="5")]
    pub stake: i64,
    /// The height at which the validator last bonded.
    #[prost(uint32, tag="6")]
    pub last_bonding_height: u32,
    /// The height at which the validator last participated in sortition.
    #[prost(uint32, tag="7")]
    pub last_sortition_height: u32,
    /// The height at which the validator will unbond.
    #[prost(uint32, tag="8")]
    pub unbonding_height: u32,
    /// The address of the validator.
    #[prost(string, tag="9")]
    pub address: ::prost::alloc::string::String,
    /// The availability score of the validator.
    #[prost(double, tag="10")]
    pub availability_score: f64,
    /// The protocol version of the validator.
    #[prost(int32, tag="11")]
    pub protocol_version: i32,
}
/// Message contains information about an account.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AccountInfo {
    /// The hash of the account.
    #[prost(string, tag="1")]
    pub hash: ::prost::alloc::string::String,
    /// The serialized data of the account.
    #[prost(string, tag="2")]
    pub data: ::prost::alloc::string::String,
    /// The unique number assigned to the account.
    #[prost(int32, tag="3")]
    pub number: i32,
    /// The balance of the account in NanoPAC.
    #[prost(int64, tag="4")]
    pub balance: i64,
    /// The address of the account.
    #[prost(string, tag="5")]
    pub address: ::prost::alloc::string::String,
}
/// Message contains information about the header of a block.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockHeaderInfo {
    /// The version of the block.
    #[prost(int32, tag="1")]
    pub version: i32,
    /// The hash of the previous block.
    #[prost(string, tag="2")]
    pub prev_block_hash: ::prost::alloc::string::String,
    /// The state root hash of the blockchain.
    #[prost(string, tag="3")]
    pub state_root: ::prost::alloc::string::String,
    /// The sortition seed of the block.
    #[prost(string, tag="4")]
    pub sortition_seed: ::prost::alloc::string::String,
    /// The address of the proposer of the block.
    #[prost(string, tag="5")]
    pub proposer_address: ::prost::alloc::string::String,
}
/// Message contains information about a certificate.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CertificateInfo {
    /// The hash of the certificate.
    #[prost(string, tag="1")]
    pub hash: ::prost::alloc::string::String,
    /// The round of the certificate.
    #[prost(int32, tag="2")]
    pub round: i32,
    /// List of committers in the certificate.
    #[prost(int32, repeated, tag="3")]
    pub committers: ::prost::alloc::vec::Vec<i32>,
    /// List of absentees in the certificate.
    #[prost(int32, repeated, tag="4")]
    pub absentees: ::prost::alloc::vec::Vec<i32>,
    /// The signature of the certificate.
    #[prost(string, tag="5")]
    pub signature: ::prost::alloc::string::String,
}
/// Message contains information about a vote.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VoteInfo {
    /// The type of the vote.
    #[prost(enumeration="VoteType", tag="1")]
    pub r#type: i32,
    /// The address of the voter.
    #[prost(string, tag="2")]
    pub voter: ::prost::alloc::string::String,
    /// The hash of the block being voted on.
    #[prost(string, tag="3")]
    pub block_hash: ::prost::alloc::string::String,
    /// The consensus round of the vote.
    #[prost(int32, tag="4")]
    pub round: i32,
    /// The change-proposer round of the vote.
    #[prost(int32, tag="5")]
    pub cp_round: i32,
    /// The change-proposer value of the vote.
    #[prost(int32, tag="6")]
    pub cp_value: i32,
}
/// Message contains information about a consensus instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusInfo {
    /// The address of the consensus instance.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    /// Indicates whether the consensus instance is active and part of the committee.
    #[prost(bool, tag="2")]
    pub active: bool,
    /// The height of the consensus instance.
    #[prost(uint32, tag="3")]
    pub height: u32,
    /// The round of the consensus instance.
    #[prost(int32, tag="4")]
    pub round: i32,
    /// List of votes in the consensus instance.
    #[prost(message, repeated, tag="5")]
    pub votes: ::prost::alloc::vec::Vec<VoteInfo>,
}
/// Message contains information about a proposal.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProposalInfo {
    /// The height of the proposal.
    #[prost(uint32, tag="1")]
    pub height: u32,
    /// The round of the proposal.
    #[prost(int32, tag="2")]
    pub round: i32,
    /// The block data of the proposal.
    #[prost(string, tag="3")]
    pub block_data: ::prost::alloc::string::String,
    /// The signature of the proposal, signed by the proposer.
    #[prost(string, tag="4")]
    pub signature: ::prost::alloc::string::String,
}
/// Enumeration for verbosity levels when requesting block information.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BlockVerbosity {
    /// Request only block data.
    Data = 0,
    /// Request block information and transaction IDs.
    Info = 1,
    /// Request block information and detailed transaction data.
    Transactions = 2,
}
impl BlockVerbosity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Data => "BLOCK_VERBOSITY_DATA",
            Self::Info => "BLOCK_VERBOSITY_INFO",
            Self::Transactions => "BLOCK_VERBOSITY_TRANSACTIONS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BLOCK_VERBOSITY_DATA" => Some(Self::Data),
            "BLOCK_VERBOSITY_INFO" => Some(Self::Info),
            "BLOCK_VERBOSITY_TRANSACTIONS" => Some(Self::Transactions),
            _ => None,
        }
    }
}
/// Enumeration for types of votes.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VoteType {
    /// Unspecified vote type.
    Unspecified = 0,
    /// Prepare vote type.
    Prepare = 1,
    /// Precommit vote type.
    Precommit = 2,
    /// Change-proposer:pre-vote vote type.
    CpPreVote = 3,
    /// Change-proposer:main-vote vote type.
    CpMainVote = 4,
    /// Change-proposer:decided vote type.
    CpDecided = 5,
}
impl VoteType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VOTE_TYPE_UNSPECIFIED",
            Self::Prepare => "VOTE_TYPE_PREPARE",
            Self::Precommit => "VOTE_TYPE_PRECOMMIT",
            Self::CpPreVote => "VOTE_TYPE_CP_PRE_VOTE",
            Self::CpMainVote => "VOTE_TYPE_CP_MAIN_VOTE",
            Self::CpDecided => "VOTE_TYPE_CP_DECIDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VOTE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "VOTE_TYPE_PREPARE" => Some(Self::Prepare),
            "VOTE_TYPE_PRECOMMIT" => Some(Self::Precommit),
            "VOTE_TYPE_CP_PRE_VOTE" => Some(Self::CpPreVote),
            "VOTE_TYPE_CP_MAIN_VOTE" => Some(Self::CpMainVote),
            "VOTE_TYPE_CP_DECIDED" => Some(Self::CpDecided),
            _ => None,
        }
    }
}
/// Request message for retrieving overall network information.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetNetworkInfoRequest {
}
/// Response message contains information about the overall network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkInfoResponse {
    /// Name of the P2P network.
    #[prost(string, tag="1")]
    pub network_name: ::prost::alloc::string::String,
    /// Number of connected peers.
    #[prost(uint32, tag="2")]
    pub connected_peers_count: u32,
    /// Metrics related to node activity.
    #[prost(message, optional, tag="4")]
    pub metric_info: ::core::option::Option<MetricInfo>,
}
/// Request message for listing peers.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListPeersRequest {
    /// If true, includes disconnected peers (default: connected peers only).
    #[prost(bool, tag="1")]
    pub include_disconnected: bool,
}
/// Response message for listing peers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPeersResponse {
    /// List of peers.
    #[prost(message, repeated, tag="1")]
    pub peers: ::prost::alloc::vec::Vec<PeerInfo>,
}
/// Request message for retrieving information of the node.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetNodeInfoRequest {
}
/// Response message contains information about a specific node in the network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeInfoResponse {
    /// Moniker or Human-readable name identifying this node in the network.
    #[prost(string, tag="1")]
    pub moniker: ::prost::alloc::string::String,
    /// Version and agent details of the node.
    #[prost(string, tag="2")]
    pub agent: ::prost::alloc::string::String,
    /// Peer ID of the node.
    #[prost(string, tag="3")]
    pub peer_id: ::prost::alloc::string::String,
    /// Unix timestamp when the node was started (UTC).
    #[prost(uint64, tag="4")]
    pub started_at: u64,
    /// Reachability status of the node.
    #[prost(string, tag="5")]
    pub reachability: ::prost::alloc::string::String,
    /// Bitfield representing the services provided by the node.
    #[prost(int32, tag="6")]
    pub services: i32,
    /// Names of services provided by the node.
    #[prost(string, tag="7")]
    pub services_names: ::prost::alloc::string::String,
    /// List of addresses associated with the node.
    #[prost(string, repeated, tag="8")]
    pub local_addrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of protocols supported by the node.
    #[prost(string, repeated, tag="9")]
    pub protocols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Offset between the node's clock and the network's clock (in seconds).
    #[prost(double, tag="13")]
    pub clock_offset: f64,
    /// Information about the node's connections.
    #[prost(message, optional, tag="14")]
    pub connection_info: ::core::option::Option<ConnectionInfo>,
    /// List of active ZeroMQ publishers.
    #[prost(message, repeated, tag="15")]
    pub zmq_publishers: ::prost::alloc::vec::Vec<ZmqPublisherInfo>,
    /// Current Unix timestamp of the node (UTC).
    #[prost(uint64, tag="16")]
    pub current_time: u64,
    /// Name of the P2P network.
    #[prost(string, tag="17")]
    pub network_name: ::prost::alloc::string::String,
}
/// ZMQPublisherInfo contains information about a ZeroMQ publisher.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ZmqPublisherInfo {
    /// The topic associated with the publisher.
    #[prost(string, tag="1")]
    pub topic: ::prost::alloc::string::String,
    /// The address of the publisher.
    #[prost(string, tag="2")]
    pub address: ::prost::alloc::string::String,
    /// The high-water mark (HWM) for the publisher, indicating the
    /// maximum number of messages to queue before dropping older ones.
    #[prost(int32, tag="3")]
    pub hwm: i32,
}
/// PeerInfo contains information about a peer in the network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerInfo {
    /// Current status of the peer (e.g., connected, disconnected).
    #[prost(int32, tag="1")]
    pub status: i32,
    /// Moniker or Human-Readable name of the peer.
    #[prost(string, tag="2")]
    pub moniker: ::prost::alloc::string::String,
    /// Version and agent details of the peer.
    #[prost(string, tag="3")]
    pub agent: ::prost::alloc::string::String,
    /// Peer ID of the peer in P2P network.
    #[prost(string, tag="4")]
    pub peer_id: ::prost::alloc::string::String,
    /// List of consensus keys used by the peer.
    #[prost(string, repeated, tag="5")]
    pub consensus_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of consensus addresses used by the peer.
    #[prost(string, repeated, tag="6")]
    pub consensus_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Bitfield representing the services provided by the peer.
    #[prost(uint32, tag="7")]
    pub services: u32,
    /// Hash of the last block the peer knows.
    #[prost(string, tag="8")]
    pub last_block_hash: ::prost::alloc::string::String,
    /// Blockchain height of the peer.
    #[prost(uint32, tag="9")]
    pub height: u32,
    /// Unix timestamp of the last bundle sent to the peer (UTC).
    #[prost(int64, tag="10")]
    pub last_sent: i64,
    /// Unix timestamp of the last bundle received from the peer (UTC).
    #[prost(int64, tag="11")]
    pub last_received: i64,
    /// Network address of the peer.
    #[prost(string, tag="12")]
    pub address: ::prost::alloc::string::String,
    /// Connection direction (e.g., inbound, outbound).
    #[prost(enumeration="Direction", tag="13")]
    pub direction: i32,
    /// List of protocols supported by the peer.
    #[prost(string, repeated, tag="14")]
    pub protocols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Total download sessions with the peer.
    #[prost(int32, tag="15")]
    pub total_sessions: i32,
    /// Completed download sessions with the peer.
    #[prost(int32, tag="16")]
    pub completed_sessions: i32,
    /// Metrics related to peer activity.
    #[prost(message, optional, tag="17")]
    pub metric_info: ::core::option::Option<MetricInfo>,
    /// Whether the hello message was sent from the outbound connection.
    #[prost(bool, tag="18")]
    pub outbound_hello_sent: bool,
}
/// ConnectionInfo contains information about the node's connections.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionInfo {
    /// Total number of connections.
    #[prost(uint64, tag="1")]
    pub connections: u64,
    /// Number of inbound connections.
    #[prost(uint64, tag="2")]
    pub inbound_connections: u64,
    /// Number of outbound connections.
    #[prost(uint64, tag="3")]
    pub outbound_connections: u64,
}
/// MetricInfo contains metrics data regarding network activity.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricInfo {
    /// Total number of invalid bundles.
    #[prost(message, optional, tag="1")]
    pub total_invalid: ::core::option::Option<CounterInfo>,
    /// Total number of bundles sent.
    #[prost(message, optional, tag="2")]
    pub total_sent: ::core::option::Option<CounterInfo>,
    /// Total number of bundles received.
    #[prost(message, optional, tag="3")]
    pub total_received: ::core::option::Option<CounterInfo>,
    /// Number of sent bundles categorized by message type.
    #[prost(map="int32, message", tag="4")]
    pub message_sent: ::std::collections::HashMap<i32, CounterInfo>,
    /// Number of received bundles categorized by message type.
    #[prost(map="int32, message", tag="5")]
    pub message_received: ::std::collections::HashMap<i32, CounterInfo>,
}
/// CounterInfo holds counter data regarding byte and bundle counts.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CounterInfo {
    /// Total number of bytes.
    #[prost(uint64, tag="1")]
    pub bytes: u64,
    /// Total number of bundles.
    #[prost(uint64, tag="2")]
    pub bundles: u64,
}
/// Request message for ping - intentionally empty for measuring round-trip time.
///
/// Empty request payload for measuring round-trip time
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PingRequest {
}
/// Response message for ping - intentionally empty for measuring round-trip time.
///
/// Empty response payload for measuring round-trip time
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PingResponse {
}
/// Direction represents the connection direction between peers.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Direction {
    /// Unknown direction (default value).
    Unknown = 0,
    /// Inbound connection - peer connected to us.
    Inbound = 1,
    /// Outbound connection - we connected to peer.
    Outbound = 2,
}
impl Direction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "DIRECTION_UNKNOWN",
            Self::Inbound => "DIRECTION_INBOUND",
            Self::Outbound => "DIRECTION_OUTBOUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DIRECTION_UNKNOWN" => Some(Self::Unknown),
            "DIRECTION_INBOUND" => Some(Self::Inbound),
            "DIRECTION_OUTBOUND" => Some(Self::Outbound),
            _ => None,
        }
    }
}
/// Request message for signing a message with a private key.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignMessageWithPrivateKeyRequest {
    /// The private key to sign the message.
    #[prost(string, tag="1")]
    pub private_key: ::prost::alloc::string::String,
    /// The message content to be signed.
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
}
/// Response message contains the signature generated from the message.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignMessageWithPrivateKeyResponse {
    /// The resulting signature in hexadecimal format.
    #[prost(string, tag="1")]
    pub signature: ::prost::alloc::string::String,
}
/// Request message for verifying a message signature.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VerifyMessageRequest {
    /// The original message content that was signed.
    #[prost(string, tag="1")]
    pub message: ::prost::alloc::string::String,
    /// The signature to verify in hexadecimal format.
    #[prost(string, tag="2")]
    pub signature: ::prost::alloc::string::String,
    /// The public key of the signer.
    #[prost(string, tag="3")]
    pub public_key: ::prost::alloc::string::String,
}
/// Response message contains the verification result.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VerifyMessageResponse {
    /// Boolean indicating whether the signature is valid for the given message and public key.
    #[prost(bool, tag="1")]
    pub is_valid: bool,
}
/// Request message for aggregating multiple BLS public keys.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PublicKeyAggregationRequest {
    /// List of BLS public keys to be aggregated.
    #[prost(string, repeated, tag="1")]
    pub public_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response message contains the aggregated BLS public key result.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PublicKeyAggregationResponse {
    /// The aggregated BLS public key.
    #[prost(string, tag="1")]
    pub public_key: ::prost::alloc::string::String,
    /// The blockchain address derived from the aggregated public key.
    #[prost(string, tag="2")]
    pub address: ::prost::alloc::string::String,
}
/// Request message for aggregating multiple BLS signatures.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignatureAggregationRequest {
    /// List of BLS signatures to be aggregated.
    #[prost(string, repeated, tag="1")]
    pub signatures: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response message contains the aggregated BLS signature.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignatureAggregationResponse {
    /// The aggregated BLS signature in hexadecimal format.
    #[prost(string, tag="1")]
    pub signature: ::prost::alloc::string::String,
}
/// AddressInfo contains detailed information about a wallet address.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AddressInfo {
    /// The address string.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    /// The public key associated with the address.
    #[prost(string, tag="2")]
    pub public_key: ::prost::alloc::string::String,
    /// A human-readable label associated with the address.
    #[prost(string, tag="3")]
    pub label: ::prost::alloc::string::String,
    /// The Hierarchical Deterministic (HD) path of the address within the wallet.
    #[prost(string, tag="4")]
    pub path: ::prost::alloc::string::String,
}
/// Request message for generating a new wallet address.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetNewAddressRequest {
    /// The name of the wallet to generate a new address.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// The type of address to generate.
    #[prost(enumeration="AddressType", tag="2")]
    pub address_type: i32,
    /// A label for the new address.
    #[prost(string, tag="3")]
    pub label: ::prost::alloc::string::String,
    /// Password for the new address. It's required when address_type is Ed25519 type.
    #[prost(string, tag="4")]
    pub password: ::prost::alloc::string::String,
}
/// Response message contains newly generated address information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetNewAddressResponse {
    /// The name of the wallet where address was generated.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// Detailed information about the new address.
    #[prost(message, optional, tag="2")]
    pub addr: ::core::option::Option<AddressInfo>,
}
/// Request message for restoring a wallet from mnemonic (seed phrase).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RestoreWalletRequest {
    /// The name for the restored wallet.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// The mnemonic (seed phrase) for wallet recovery.
    #[prost(string, tag="2")]
    pub mnemonic: ::prost::alloc::string::String,
    /// Password to secure the restored wallet.
    #[prost(string, tag="3")]
    pub password: ::prost::alloc::string::String,
}
/// Response message confirming wallet restoration.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RestoreWalletResponse {
    /// The name of the restored wallet.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
}
/// Request message for creating a new wallet.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateWalletRequest {
    /// The name for the new wallet.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// Password to secure the new wallet.
    #[prost(string, tag="2")]
    pub password: ::prost::alloc::string::String,
}
/// Response message contains wallet recovery mnemonic (seed phrase).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateWalletResponse {
    /// The name for the new wallet.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// The mnemonic (seed phrase) for wallet recovery.
    #[prost(string, tag="2")]
    pub mnemonic: ::prost::alloc::string::String,
}
/// Request message for loading an existing wallet.
/// Deprecated: It will be removed in a future version.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoadWalletRequest {
    /// The name of the wallet to load.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
}
/// Response message confirming wallet loaded.
/// Deprecated: It will be removed in a future version.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoadWalletResponse {
    /// The name of the loaded wallet.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
}
/// Request message for unloading a wallet.
/// Deprecated: It will be removed in a future version.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnloadWalletRequest {
    /// The name of the wallet to unload.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
}
/// Response message confirming wallet unloading.
/// Deprecated: It will be removed in a future version.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnloadWalletResponse {
    /// The name of the unloaded wallet.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
}
/// Request message for obtaining the validator address associated with a public key.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetValidatorAddressRequest {
    /// The public key of the validator.
    #[prost(string, tag="1")]
    pub public_key: ::prost::alloc::string::String,
}
/// Response message containing the validator address corresponding to a public key.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetValidatorAddressResponse {
    /// The validator address associated with the public key.
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
}
/// Request message for signing a raw transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignRawTransactionRequest {
    /// The name of the wallet used for signing.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// The raw transaction data to be signed.
    #[prost(string, tag="2")]
    pub raw_transaction: ::prost::alloc::string::String,
    /// Wallet password required for signing.
    #[prost(string, tag="3")]
    pub password: ::prost::alloc::string::String,
}
/// Response message contains the transaction ID and signed raw transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignRawTransactionResponse {
    /// The ID of the signed transaction.
    #[prost(string, tag="1")]
    pub transaction_id: ::prost::alloc::string::String,
    /// The signed raw transaction data.
    #[prost(string, tag="2")]
    pub signed_raw_transaction: ::prost::alloc::string::String,
}
/// Request message for obtaining the total available balance of a wallet.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTotalBalanceRequest {
    /// The name of the wallet to get the total balance.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
}
/// Response message contains the total available balance of the wallet.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTotalBalanceResponse {
    /// The name of the queried wallet.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// The total balance of the wallet in NanoPAC.
    #[prost(int64, tag="2")]
    pub total_balance: i64,
}
/// Request message to sign an arbitrary message.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignMessageRequest {
    /// The name of the wallet to sign with.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// Wallet password required for signing.
    #[prost(string, tag="2")]
    pub password: ::prost::alloc::string::String,
    /// The address whose private key should be used for signing the message.
    #[prost(string, tag="3")]
    pub address: ::prost::alloc::string::String,
    /// The arbitrary message to be signed.
    #[prost(string, tag="4")]
    pub message: ::prost::alloc::string::String,
}
/// Response message contains message signature.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignMessageResponse {
    /// The signature in hexadecimal format.
    #[prost(string, tag="1")]
    pub signature: ::prost::alloc::string::String,
}
/// Request message for obtaining the total stake of a wallet.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTotalStakeRequest {
    /// The name of the wallet to get the total stake.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
}
/// Response message contains the total stake of the wallet.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTotalStakeResponse {
    /// The name of the queried wallet.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// The total stake amount in NanoPAC.
    #[prost(int64, tag="2")]
    pub total_stake: i64,
}
/// Request message for getting address information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAddressInfoRequest {
    /// The name of the wallet containing the address.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// The address to query.
    #[prost(string, tag="2")]
    pub address: ::prost::alloc::string::String,
}
/// Response message contains address details.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAddressInfoResponse {
    /// The name of the wallet containing the address.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// Detailed information about the address.
    #[prost(message, optional, tag="2")]
    pub addr: ::core::option::Option<AddressInfo>,
}
/// Request message for setting address label.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetAddressLabelRequest {
    /// The name of the wallet containing the address.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// Wallet password required for modification.
    #[prost(string, tag="2")]
    pub password: ::prost::alloc::string::String,
    /// The address to label.
    #[prost(string, tag="3")]
    pub address: ::prost::alloc::string::String,
    /// The new label for the address.
    #[prost(string, tag="4")]
    pub label: ::prost::alloc::string::String,
}
/// Response message for updated address label.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetAddressLabelResponse {
    /// The name of the wallet where the address label was updated.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// The address where the label was updated.
    #[prost(string, tag="2")]
    pub address: ::prost::alloc::string::String,
    /// The new label for the address.
    #[prost(string, tag="3")]
    pub label: ::prost::alloc::string::String,
}
/// Request message for listing wallets.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListWalletsRequest {
}
/// Response message contains wallet names.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListWalletsResponse {
    /// Array of wallet names.
    #[prost(string, repeated, tag="1")]
    pub wallets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for getting wallet information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetWalletInfoRequest {
    /// The name of the wallet to query.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
}
/// Response message contains wallet details.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetWalletInfoResponse {
    /// The name of the wallet.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// The wallet format version.
    #[prost(int32, tag="2")]
    pub version: i32,
    /// The network the wallet is connected to (e.g., mainnet, testnet).
    #[prost(string, tag="3")]
    pub network: ::prost::alloc::string::String,
    /// Indicates if the wallet is encrypted.
    #[prost(bool, tag="4")]
    pub encrypted: bool,
    /// A unique identifier of the wallet.
    #[prost(string, tag="5")]
    pub uuid: ::prost::alloc::string::String,
    /// Unix timestamp of wallet creation.
    #[prost(int64, tag="6")]
    pub created_at: i64,
    /// The default fee of the wallet.
    #[prost(int64, tag="7")]
    pub default_fee: i64,
    /// The storage driver used by the wallet (e.g., SQLite, Legacy JSON ).
    #[prost(string, tag="8")]
    pub driver: ::prost::alloc::string::String,
    /// Path to the wallet file or storage location.
    #[prost(string, tag="9")]
    pub path: ::prost::alloc::string::String,
}
/// Request message for listing wallet addresses.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAddressesRequest {
    /// The name of the queried wallet.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// Filter addresses by their types. If empty, all address types are included.
    #[prost(enumeration="AddressType", repeated, tag="2")]
    pub address_types: ::prost::alloc::vec::Vec<i32>,
}
/// Response message contains wallet addresses.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAddressesResponse {
    /// The name of the queried wallet.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// List of all addresses in the wallet with their details.
    #[prost(message, repeated, tag="2")]
    pub addrs: ::prost::alloc::vec::Vec<AddressInfo>,
}
/// Request message for updating wallet password.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdatePasswordRequest {
    /// The name of the wallet whose password will be updated.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// The current wallet password.
    #[prost(string, tag="2")]
    pub old_password: ::prost::alloc::string::String,
    /// The new wallet password.
    #[prost(string, tag="3")]
    pub new_password: ::prost::alloc::string::String,
}
/// Response message confirming wallet password update.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdatePasswordResponse {
    /// The name of the wallet whose password was updated.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
}
/// WalletTransactionInfo contains information about a transaction in a wallet.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WalletTransactionInfo {
    /// A sequence number for the transaction in the wallet.
    #[prost(int64, tag="1")]
    pub no: i64,
    /// The unique ID of the transaction.
    #[prost(string, tag="2")]
    pub tx_id: ::prost::alloc::string::String,
    /// The sender's address.
    #[prost(string, tag="3")]
    pub sender: ::prost::alloc::string::String,
    /// The receiver's address.
    #[prost(string, tag="4")]
    pub receiver: ::prost::alloc::string::String,
    /// The direction of the transaction relative to the wallet.
    #[prost(enumeration="TxDirection", tag="5")]
    pub direction: i32,
    /// The amount involved in the transaction in NanoPAC.
    #[prost(int64, tag="6")]
    pub amount: i64,
    /// The transaction fee in NanoPAC.
    #[prost(int64, tag="7")]
    pub fee: i64,
    /// A memo string for the transaction.
    #[prost(string, tag="8")]
    pub memo: ::prost::alloc::string::String,
    /// The current status of the transaction.
    #[prost(enumeration="TransactionStatus", tag="9")]
    pub status: i32,
    /// The block height containing the transaction.
    #[prost(uint32, tag="10")]
    pub block_height: u32,
    /// The type of transaction payload.
    #[prost(enumeration="PayloadType", tag="11")]
    pub payload_type: i32,
    /// The raw transaction data.
    #[prost(bytes="vec", tag="12")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// A comment associated with the transaction in the wallet.
    #[prost(string, tag="13")]
    pub comment: ::prost::alloc::string::String,
    /// Unix timestamp of when the transaction was created.
    #[prost(int64, tag="14")]
    pub created_at: i64,
    /// Unix timestamp of when the transaction was last updated.
    #[prost(int64, tag="15")]
    pub updated_at: i64,
}
/// Request message for listing transactions of a wallet, optionally filtered by a specific address.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTransactionsRequest {
    /// The name of the wallet to query transactions for.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// Optional: The address to filter transactions.
    /// If empty or set to '*', transactions for all addresses in the wallet are included.
    #[prost(string, tag="2")]
    pub address: ::prost::alloc::string::String,
    /// Filter transactions by direction relative to the wallet.
    /// Defaults to any direction if not set.
    #[prost(enumeration="TxDirection", tag="3")]
    pub direction: i32,
    /// Optional: The maximum number of transactions to return.
    /// Defaults to 10 if not set.
    #[prost(int32, tag="4")]
    pub count: i32,
    /// Optional: The number of transactions to skip (for pagination).
    /// Defaults to 0 if not set.
    #[prost(int32, tag="5")]
    pub skip: i32,
}
/// Response message containing a list of transactions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransactionsResponse {
    /// The name of the wallet queried.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// List of transactions for the wallet, filtered by the specified address if provided.
    #[prost(message, repeated, tag="2")]
    pub txs: ::prost::alloc::vec::Vec<WalletTransactionInfo>,
}
/// Request message for setting default fee.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetDefaultFeeRequest {
    /// The name of the wallet to set the default fee.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// The default fee amount in NanoPAC.
    #[prost(int64, tag="2")]
    pub amount: i64,
}
/// Response message for updated default fee.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetDefaultFeeResponse {
    /// The name of the wallet where the default fee was updated.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
}
/// Request message for getting mnemonic.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMnemonicRequest {
    /// The name of the wallet to get the mnemonic.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// Wallet password.
    #[prost(string, tag="2")]
    pub password: ::prost::alloc::string::String,
}
/// Response message contains mnemonic.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMnemonicResponse {
    /// The mnemonic (seed phrase).
    #[prost(string, tag="1")]
    pub mnemonic: ::prost::alloc::string::String,
}
/// Request message for getting private key.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPrivateKeyRequest {
    /// The name of the wallet containing the address.
    #[prost(string, tag="1")]
    pub wallet_name: ::prost::alloc::string::String,
    /// Wallet password.
    #[prost(string, tag="2")]
    pub password: ::prost::alloc::string::String,
    /// The address to get the private key.
    #[prost(string, tag="3")]
    pub address: ::prost::alloc::string::String,
}
/// Response message contains private key.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPrivateKeyResponse {
    /// The private key in hexadecimal format.
    #[prost(string, tag="1")]
    pub private_key: ::prost::alloc::string::String,
}
/// AddressType defines different types of blockchain addresses.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AddressType {
    /// Treasury address type.
    /// Should not be used to generate new addresses.
    Treasury = 0,
    /// Validator address type used for validator nodes.
    Validator = 1,
    /// Account address type with BLS signature scheme.
    BlsAccount = 2,
    /// Account address type with Ed25519 signature scheme.
    /// Note: Generating a new Ed25519 address requires the wallet password.
    Ed25519Account = 3,
}
impl AddressType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Treasury => "ADDRESS_TYPE_TREASURY",
            Self::Validator => "ADDRESS_TYPE_VALIDATOR",
            Self::BlsAccount => "ADDRESS_TYPE_BLS_ACCOUNT",
            Self::Ed25519Account => "ADDRESS_TYPE_ED25519_ACCOUNT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ADDRESS_TYPE_TREASURY" => Some(Self::Treasury),
            "ADDRESS_TYPE_VALIDATOR" => Some(Self::Validator),
            "ADDRESS_TYPE_BLS_ACCOUNT" => Some(Self::BlsAccount),
            "ADDRESS_TYPE_ED25519_ACCOUNT" => Some(Self::Ed25519Account),
            _ => None,
        }
    }
}
/// TxDirection indicates the direction of a transaction relative to the wallet.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TxDirection {
    /// include both incoming and outgoing transactions.
    Any = 0,
    /// Include only incoming transactions where the wallet receives funds.
    Incoming = 1,
    /// Include only outgoing transactions where the wallet sends funds.
    Outgoing = 2,
}
impl TxDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Any => "TX_DIRECTION_ANY",
            Self::Incoming => "TX_DIRECTION_INCOMING",
            Self::Outgoing => "TX_DIRECTION_OUTGOING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TX_DIRECTION_ANY" => Some(Self::Any),
            "TX_DIRECTION_INCOMING" => Some(Self::Incoming),
            "TX_DIRECTION_OUTGOING" => Some(Self::Outgoing),
            _ => None,
        }
    }
}
/// TransactionStatus defines the status of a transaction.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionStatus {
    /// Pending status for transactions in the mempool.
    Pending = 0,
    /// Confirmed status for transactions included in a block.
    Confirmed = 1,
    /// Failed status for transactions that were not successful.
    Failed = -1,
}
impl TransactionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Pending => "TRANSACTION_STATUS_PENDING",
            Self::Confirmed => "TRANSACTION_STATUS_CONFIRMED",
            Self::Failed => "TRANSACTION_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_STATUS_PENDING" => Some(Self::Pending),
            "TRANSACTION_STATUS_CONFIRMED" => Some(Self::Confirmed),
            "TRANSACTION_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
include!("pactus.serde.rs");
include!("pactus.tonic.rs");
// @@protoc_insertion_point(module)