package payload

import (
	"io"
	"testing"

	"github.com/pactus-project/pactus/crypto"
	"github.com/pactus-project/pactus/types/amount"
	"github.com/pactus-project/pactus/util"
	"github.com/stretchr/testify/assert"
)

func TestBatchTransferType(t *testing.T) {
	pld := BatchTransferPayload{}
	assert.Equal(t, TypeBatchTransfer, pld.Type())
}

func TestBatchTransferString(t *testing.T) {
	pld := BatchTransferPayload{}
	assert.Contains(t, pld.String(), "{BatchTransfer ")
}

func TestBatchTransferDecoding(t *testing.T) {
	tests := []struct {
		raw      []byte
		value    amount.Amount
		readErr  error
		basicErr error
	}{
		{
			raw:      []byte{},
			value:    0,
			readErr:  io.EOF,
			basicErr: nil,
		},
		{
			raw: []byte{
				0x00, // sender (Treasury)
				0x02, // number Of Recipients (2)
				0x02, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				0x21, 0x12, 0x23, 0x24, // receiver-1
			},
			value:    0,
			readErr:  io.ErrUnexpectedEOF,
			basicErr: nil,
		},
		{
			raw: []byte{
				0x00, // sender (Treasury)
				0x02, // number Of Recipients (2)
				0x02, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				0x21, 0x12, 0x23, 0x24, 0x25, // receiver-1
				0x80, 0x80, 0x80, // amount-1
			},
			value:    0,
			readErr:  io.EOF,
			basicErr: nil,
		},
		{
			raw: []byte{
				0x00, // sender (Treasury)
				0x01, // number Of Recipients (1)
				0x02, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				0x21, 0x12, 0x23, 0x24, 0x25, // receiver-1
				0x80, 0x80, 0x80, 0x01, // amount-1
			},
			value:   0,
			readErr: nil,
			basicErr: BasicCheckError{
				Reason: "recipients must be between 2 and 8",
			},
		},
		{
			raw: []byte{
				0x00, // sender (Treasury)
				0x02, // number Of Recipients (2)
				0x02, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				0x21, 0x12, 0x23, 0x24, 0x25, // receiver-1
				0x80, 0x80, 0x80, 0x01, // amount-1
				0x02, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x19, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
				0x41, 0x42, 0x43, 0x44, 0x45, // receiver-2
				0x80, 0x80, 0x80, // amount-2
			},
			value:    0,
			readErr:  io.EOF,
			basicErr: nil,
		},
		{
			raw: []byte{
				0x00, // sender (Treasury)
				0x02, // number Of Recipients (2)
				0x02, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				0x21, 0x12, 0x23, 0x24, 0x25, // receiver-1
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, // amount-1 (Negative)
				0x02, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x19, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
				0x41, 0x42, 0x43, 0x44, 0x45, // receiver-2
				0x80, 0x80, 0x80, 0x02, // amount-2
			},
			value:   0x200000 + 0x400000,
			readErr: nil,
			basicErr: BasicCheckError{
				Reason: "amount must be greater than zero: -1",
			},
		},
		{
			raw: []byte{
				0x00, // sender (Treasury)
				0x02, // number Of Recipients (2)
				0x02, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				0x21, 0x12, 0x23, 0x24, 0x25, // receiver-1
				0x80, 0x80, 0x80, 0x01, // amount-1
				0x02, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x19, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
				0x41, 0x42, 0x43, 0x44, 0x45, // receiver-2
				0x80, 0x80, 0x80, 0x02, // amount-2
			},
			value:    0x200000 + 0x400000,
			readErr:  nil,
			basicErr: nil,
		},
		{
			raw: []byte{
				0x02, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x11, 0x12, 0x13, 0x14, // sender
			},
			value:    0,
			readErr:  io.ErrUnexpectedEOF,
			basicErr: nil,
		},
		{
			raw: []byte{
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x15, // sender
				0x02, // number Of Recipients (2)
				0x02, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				0x21, 0x12, 0x23, 0x24, 0x25, // receiver-1
				0x80, 0x80, 0x80, 0x01, // amount-1
				0x02, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x19, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
				0x41, 0x42, 0x43, 0x44, 0x45, // receiver-2
				0x80, 0x80, 0x80, 0x02, // amount-2
			},
			value:   0x200000,
			readErr: nil,
			basicErr: BasicCheckError{
				Reason: "sender is not an account address: pc1pqgpsgpgxquyqjzstpsxsurcszyfpx9q4vllmut",
			},
		},
		{
			raw: []byte{
				0x02, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x15, // sender
				0x02, // number Of Recipients (2)
				0x01, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				0x21, 0x12, 0x23, 0x24, 0x25, // receiver-1
				0x80, 0x80, 0x80, 0x01, // amount-1
				0x02, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x19, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
				0x41, 0x42, 0x43, 0x44, 0x45, // receiver-2
				0x80, 0x80, 0x80, 0x02, // amount-2
			},
			value:   0x200000,
			readErr: nil,
			basicErr: BasicCheckError{
				Reason: "receiver is not an account address: pc1pzgf3g9gkzuvpjxsmrsw3u8eqyyfzxfp9ex44d6",
			},
		},
		{
			raw: []byte{
				0x02, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x15, // sender
				0x02, // number Of Recipients (2)
				0x02, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				0x21, 0x12, 0x23, 0x24, 0x25, // receiver-1
				0x80, 0x80, 0x80, 0x01, // amount-1
				0x02, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x19, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
				0x41, 0x42, 0x43, 0x44, 0x45, // receiver-2
				0x80, 0x80, 0x80, 0x02, // amount-2
			},
			value:    0x600000,
			readErr:  nil,
			basicErr: nil,
		},
	}

	for no, tt := range tests {
		pld := BatchTransferPayload{}
		r := util.NewFixedReader(len(tt.raw), tt.raw)
		err := pld.Decode(r)
		if tt.readErr != nil {
			assert.ErrorIs(t, err, tt.readErr)
		} else {
			assert.NoError(t, err)

			for i := 0; i < pld.SerializeSize(); i++ {
				w := util.NewFixedWriter(i)
				assert.Error(t, pld.Encode(w), "encode test %v failed", no)
			}
			w := util.NewFixedWriter(pld.SerializeSize())
			assert.NoError(t, pld.Encode(w))
			assert.Equal(t, pld.SerializeSize(), len(w.Bytes()))
			assert.Equal(t, tt.raw, w.Bytes())

			// Basic check
			if tt.basicErr != nil {
				assert.ErrorIs(t, pld.BasicCheck(), tt.basicErr)
			} else {
				assert.NoError(t, pld.BasicCheck())

				// Check signer
				if tt.raw[0] != 0 {
					assert.Equal(t, crypto.Address(tt.raw[:21]), pld.Signer())
				} else {
					assert.Equal(t, crypto.TreasuryAddress, pld.Signer())
				}
				assert.Equal(t, tt.value, pld.Value())
			}
		}
	}
}
